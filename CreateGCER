#include <kipr/botball.h>

int main()
{
    //intro
    create_connect();
    // REFER TO THESE NUMBERS IF A CORD IS UMPLUGED //
    int frontArm = 1;
    int backArm = 0;
    int lightSensor = 1;
    int leftLineSensor = 0;
    int rightLineSensor = 2;
    int buldingSensor = 3;
    int timer = 0;
    int i;
    int battery;
    int path;
    msleep(2000); //get away from arms time
    set_servo_position(frontArm, 1790);
    set_servo_position(backArm, 0);
    battery = get_create_battery_charge() - 2600;
	printf("Create Battery Power Before Run: %d",battery);
    //WAIT FOR LIGHT NEEDS TO BE ADDED HERE LATER
    enable_servos();
    shut_down_in(119);
	printf("Create Battery Power At Start: %d",battery);
    //part 1: sweep the center line without people
    
    //get out of the starting box
    create_drive_direct(-100,-100);
    msleep(1000);
    create_stop();
	create_drive_direct(300,300);
    msleep(750);
    create_stop();

    //approach the start of the line
    create_spin_CW(200);
    msleep(960);
    create_stop();
    
    //drive paralel to the starting line
    create_drive_direct(300,300);
    msleep(2400);
    create_stop();
    
    //turn to face of the line
	create_spin_CW(200);
    msleep(960);
    create_stop();
    
    //check the gray and black line is passed before moving a bit farther to turn
    while (analog(rightLineSensor) < 2500){
        create_drive_direct(-100,-100);
    }
    create_stop();
    msleep(500);
	create_drive_direct(-100,-100);
    msleep(1250);
    create_stop();
	
    //turn to prep for the line and camera code
	create_spin_CCW(200);
    msleep(960);
    create_stop();
    
    //camera line follow
    set_servo_position(backArm,1930);
    msleep(500);
    while (timer < 56){ //to change time, add two zeros to however many seconds you want it to double line follow
        if (analog(leftLineSensor) > 2500 && analog(rightLineSensor) > 2500){ //1800
            create_drive_direct(-250,-250);
            msleep(100);
            timer = timer + 1;
        }
        else if (analog(leftLineSensor) > 2500 && analog(rightLineSensor) < 2500){
            create_drive_direct(0,-250);
            msleep(100);
            timer = timer + 1.5;
    	}
    	else if (analog(leftLineSensor) < 2500 && analog(rightLineSensor) > 2500) {
            create_drive_direct(-250,0);
            msleep(100);
            timer = timer + 1.5;
        }
        else{
			create_drive_direct(-125,-250);
            msleep(100);
            timer = timer + 1;
        }
    }
          create_stop();
    	  timer = 0;
    		msleep(1000);
    while (analog(buldingSensor) < 1300){ 
        if (analog(leftLineSensor) > 2500 && analog(rightLineSensor) > 2500){
            create_drive_direct(-125,-125);
            msleep(100);
        }
        else if (analog(leftLineSensor) > 2500 && analog(rightLineSensor) < 2500){
            create_drive_direct(0,-125);
            msleep(100);
    	}
    	else if (analog(leftLineSensor) < 2500 && analog(rightLineSensor) > 2500) {
            create_drive_direct(-125,0);
            msleep(100);
        }
        else{
			create_drive_direct(-65,-125);
            msleep(100);
        }
    }
          create_stop();
   		
    	//check which buliding to deliver suplies too
    	set_servo_position(backArm,0);
    	camera_open_black();
    	while (timer < 300){
    		camera_update();
            msleep(1);
            timer = timer + 1;
        }
    	set_servo_position(backArm, 1925);
    	msleep(500);
        if (get_object_area(0,0) >=50) //turn if it sees an object 100
        {
           create_drive_direct(0,-200);
           msleep(800);
           create_drive_direct(-200,-200);
           msleep(1200);
           create_drive_direct(200,200);
           msleep(1200);
           create_drive_direct(0,200);
           msleep(800);
           create_drive_direct(200,200);
           msleep(200);
           path = 1;
        }
    	else
        {
           create_drive_direct(-200,-200);
           msleep(1200);
           create_drive_direct(200,200);
           msleep(1400);
           path = 0;
    	}
    camera_close();
    timer = 0;
    create_stop();
    set_servo_position(backArm,0);
  	printf("Create Battery Power At Part 2: %d",battery);
        
    //part 2: collect and sweep the people
    
    //get people
    create_spin_CCW(200);
    msleep(960);
    create_stop();
    
    set_servo_position(frontArm, 1250);
    msleep(250);
    set_servo_position(frontArm, 620);
    msleep(250);
    create_drive_direct(50,50);
    msleep(3650); //4000 3750 3650
    set_servo_position(frontArm, 125);
    msleep(250);
    create_drive_direct(-250,-250);//75
    msleep(1975);//6000 1875
    create_stop();
    msleep(1000);
    
    //loop to grab people
    while(i<3){
        //lift arm up
        set_servo_position(frontArm,1250);
        msleep(250);
        set_servo_position(frontArm,1790);
        msleep(250);
        //back up to wall
        create_drive_direct(-400,-400);//100 200
        msleep(1000);//1000 2500 1250
        //forward and turn to next building
        create_drive_direct(200,200);//200
        msleep(500);//1000
        create_spin_CW(200);
        msleep(960);
        create_stop();
        //distance between the two buildings
        create_drive_direct(200,200);
        msleep(1490); //2000 1750 1650 1700 1675 1575 1525
        create_spin_CCW(200);
        msleep(960);
        create_stop();
        //drive to next building
        create_drive_direct(200,200);//100
        msleep(500);//1000
        //lower arm
        set_servo_position(frontArm, 1250);
    	msleep(250);
    	set_servo_position(frontArm, 620);
    	msleep(250);
    	create_drive_direct(75,75);
    	msleep(6000);
        //lower down behind people and back up
    	set_servo_position(frontArm, 125);
    	msleep(250);
    	create_drive_direct(-250,-250);//75 125
    	msleep(1975);//6000 3750 1875
    	create_stop();
    	msleep(1000);
        i++;
    }
    
    //lift wall and back up
    set_servo_position(frontArm,1250);
    msleep(250);
    set_servo_position(frontArm,1790);
    msleep(250);
    create_drive_direct(-400,-400);//200
    msleep(1000);//2500 1250
    
    //set up for line follow again
    create_drive_direct(200,200);
    msleep(750);//250
    create_spin_CW(200);
    msleep(960);
    create_stop();
    msleep(250);
    create_drive_direct(100,100);
    msleep(2500);
    create_spin_CW(200);
    msleep(960);
    create_stop();
    msleep(250);
    
    //check the gray and black line is passed before moving a bit farther to turn
    while (analog(rightLineSensor) < 2500){
        create_drive_direct(-100,-100);
    }
    create_stop();
    msleep(500);
	create_drive_direct(-100,-100);
    msleep(1250);
    create_stop();
	
    //turn to prep for the line and camera code
	create_spin_CCW(200);
    msleep(960);
    create_stop();
    
    //camera line follow
    set_servo_position(backArm,1930);
    msleep(500);
    while (timer < 52){ //to change time, add two zeros to however many seconds you want it to double line follow
        if (analog(leftLineSensor) > 2500 && analog(rightLineSensor) > 2500){ //1800
            create_drive_direct(-250,-250);
            msleep(100);
            timer = timer + 1;
        }
        else if (analog(leftLineSensor) > 2500 && analog(rightLineSensor) < 2500){
            create_drive_direct(0,-250);
            msleep(100);
            timer = timer + 1.5;
    	}
    	else if (analog(leftLineSensor) < 2500 && analog(rightLineSensor) > 2500) {
            create_drive_direct(-250,0);
            msleep(100);
            timer = timer + 1.5;
        }
        else{
			create_drive_direct(-125,-250);
            msleep(100);
            timer = timer + 1;
        }
    }
          create_stop();
    	  timer = 0;
    		msleep(1000);
    while (analog(buldingSensor) < 1300){ 
        if (analog(leftLineSensor) > 2500 && analog(rightLineSensor) > 2500){
            create_drive_direct(-125,-125);
            msleep(100);
        }
        else if (analog(leftLineSensor) > 2500 && analog(rightLineSensor) < 2500){
            create_drive_direct(0,-125);
            msleep(100);
    	}
    	else if (analog(leftLineSensor) < 2500 && analog(rightLineSensor) > 2500) {
            create_drive_direct(-125,0);
            msleep(100);
        }
        else{
			create_drive_direct(-65,-125);
            msleep(100);
        }
    }
          create_stop();
		if (path == 1) //the split path for this part usese the previous camera judgment
        {
           create_drive_direct(0,-200);
           msleep(800);
           create_drive_direct(-200,-200);
           msleep(1200);
           create_drive_direct(200,200);
           msleep(1200);
           create_drive_direct(0,200);
           msleep(800);
           create_drive_direct(200,200);
           msleep(200);
        }
    	else
        {
           create_drive_direct(-200,-200);
           msleep(1200);
           create_drive_direct(200,200);
           msleep(1400);
    	}
   		
    //end of the program
    create_disconnect();
	msleep(500);
    return 0;
}
